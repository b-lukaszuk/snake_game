{"version":3,"sources":["components/Button.tsx","config/config.ts","components/canvas/draw/displayGameOver.ts","components/canvas/draw/drawBlock.ts","components/canvas/draw/setCanvasDefaults.ts","types/Direction.ts","components/canvas/Canvas.tsx","utils/eatFood.ts","components/GameStatus.tsx","utils/randInt.ts","utils/isBlockInSnake.ts","utils/getRandBlock.ts","components/Instructions.tsx","utils/shiftSnake.ts","components/RadioSelect.tsx","utils/willSnakeHitWall.ts","utils/willSnakeEatItself.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Button","props","displText","onClickAction","onClick","config","displayGameOver","ctx","canv","score","fontSize","height","toFixed","clearRect","width","font","textAlign","textBaseline","fillStyle","fillText","parseInt","drawBlock","rowId","colId","blockWidth","blockHeight","color","blockMargin","Math","round","xStartPx","yStartPx","fillRect","setCanvasDefaults","Direction","Canvas","canvasRef","useRef","food","foodColor","isGameOver","nRows","snake","snakeColor","useEffect","canvas","current","getContext","forEach","b","x","y","ref","className","eatFood","newSnake","slice","unshift","GameStatus","randInt","min","max","result","i","arguments","Error","length","ceil","floor","random","isBlockInSnake","block","getRandBlock","minIncl","maxExcl","getFreeRandBlock","randBlock","Instructions","shiftBlock","direction","Up","Down","Right","RadioSelect","mainLabel","groupName","choices","selectedChoice","actionOnSelect","onSelect","choice","value","action","map","c","type","name","onChange","checked","htmlFor","id","willSnakeHitWall","noOfRows","newHead","outOfX","outOfY","willSnakeEatItself","App","useState","delay","setDelay","setFood","gameOver","setGameOver","nOfRows","setNrows","maxSnakeLength","setMaxSnakeLength","moveDirection","setMoveDirection","setSnake","setScore","handleKeyDown","event","newDirection","key","Left","abs","document","addEventListener","removeEventListener","moveSnake","prevSnake","shiftSnake","onGameOver","clearInterval","timerId","setInterval","willSnakeEatFood","prevScore","delayMicroSecs","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d8823179.chunk.js","sourcesContent":["import { ReactElement } from \"react\";\n\nimport \"./Button.css\";\n\ninterface Props {\n    displText: string;\n    onClick: (event: React.MouseEvent<HTMLElement>) => void;\n}\n\nconst Button: React.FC<Props> = (props): ReactElement<HTMLElement> => {\n    const displText: string = props.displText;\n    const onClickAction: (e: React.MouseEvent<HTMLElement>) => void = props.onClick;\n\n    return (\n        <button onClick={onClickAction}>\n            {displText}\n        </button>\n    )\n}\n\nexport default Button;\n","const config = {\n    \"delay\": 1000,\n    \"food\": { \"x\": 3, \"y\": 3 },\n    \"foodColor\": \"red\",\n    // important condition: nOfRows is always equal to nOfCols (gameField is square)\n    \"nOfRows\": 5,\n    // x, y coordinates work similarly to nrow, ncol in Python's pd.DataFrame indexing\n    \"snake\": [\n        { \"x\": 0, \"y\": 2 },\n        { \"x\": 0, \"y\": 1 },\n        { \"x\": 0, \"y\": 0 },\n    ],\n    \"snakeColor\": \"blue\",\n}\n\nexport default config;\n","function displayGameOver(ctx: CanvasRenderingContext2D,\n    canv: HTMLCanvasElement, score: number): void {\n\n    let fontSize: string = (canv.height / 8).toFixed(0);\n    ctx.clearRect(0, 0, canv.width, canv.height);\n    ctx.font = `${fontSize}px Arial`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = \"#ff3333\";\n    ctx.fillText(\"Game Over\", (canv.width / 2),\n        (canv.height / 2) - parseInt(fontSize));\n    ctx.fillText(`Score: ${score}`,\n        (canv.width / 2), (canv.height / 2) + parseInt(fontSize));\n\n}\n\nexport default displayGameOver;\n","// it draws snake by indexing the fields like rows and cols like in\n// Python's pd.DataFrame object\nfunction drawBlock(ctx: CanvasRenderingContext2D,\n    rowId: number, colId: number,\n    blockWidth: number, blockHeight: number,\n    color: string = \"blue\"): void {\n\n    let blockMargin: number = Math.round(blockWidth * 0.05);\n\n    ctx.fillStyle = color;\n    let xStartPx: number = (rowId * blockHeight) + 1; // upper left corner\n    let yStartPx: number = (colId * blockWidth) + 1; // upper left corner\n    ctx.fillRect(yStartPx, xStartPx, blockWidth - blockMargin,\n        blockHeight - blockMargin);\n}\n\nexport default drawBlock;\n","function setCanvasDefaults(canv: HTMLCanvasElement): void {\n    canv.width = 500;\n    canv.height = 500;\n}\n\nexport default setCanvasDefaults;\n","enum Direction {\n    Up = 1,\n    Down = 10,\n    Right = 2,\n    Left = 11,\n}\n// such a set of numbers prevents backtracking the snake (turning 180 deg)\n// by checking the following:\n// if(Math.abs(newDirection - moveDirection) !== 9) {changeDirection()}\n\nexport default Direction;\n","import React, { ReactElement, useEffect, useRef } from \"react\";\n\nimport Block from \"../..//interfaces/Block\";\nimport config from \"../../config/config\";\nimport displayGameOver from \"./draw/displayGameOver\";\nimport drawBlock from \"./draw/drawBlock\";\nimport setCanvasDefaults from \"./draw/setCanvasDefaults\";\n\nimport \"./Canvas.css\";\n\ninterface Props {\n    food: Block;\n    isGameOver: boolean;\n    score: number;\n    snake: Block[];\n    nRows: number;\n}\n\nconst Canvas: React.FC<Props> = (props): ReactElement<HTMLElement> => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n    const food: Block = props.food;\n    const foodColor: string = config.foodColor;\n    const isGameOver: boolean = props.isGameOver;\n    // nRows is always equal nCols\n    const nRows: number = props.nRows;\n    const score: number = props.score;\n    // x, y coordinates work similarly to nrow, ncol in Python's pd.DataFrame indexing\n    const snake: Block[] = props.snake;\n    const snakeColor: string = config.snakeColor;\n\n    useEffect(() => {\n        const canvas: HTMLCanvasElement | null = canvasRef.current;\n        if (canvas === null) {\n            return undefined;\n        }\n        const blockWidth: number = canvas.width / nRows;\n        const blockHeight: number = canvas.height / nRows;\n        setCanvasDefaults(canvas);\n        const ctx: CanvasRenderingContext2D | null = canvas.getContext(\"2d\");\n        if (ctx === null) {\n            return undefined;\n        }\n        snake.forEach((b) =>\n            drawBlock(ctx, b.x, b.y, blockWidth, blockHeight, snakeColor)\n        );\n        drawBlock(ctx, food.x, food.y, blockWidth, blockHeight, foodColor);\n\n        if (isGameOver) {\n            displayGameOver(ctx, canvas, score);\n        }\n    }, [snake, food, nRows, foodColor, snakeColor, isGameOver, score]);\n\n    return (\n        <div>\n            <canvas width=\"500\" height=\"500\" ref={canvasRef} className=\"canvas\" />\n        </div>\n    );\n};\n\nexport default Canvas;\n","import Block from '../interfaces/Block';\n\n// returns a new snake (after eating a food)\nfunction eatFood(snake: Block[], food: Block): Block[] {\n    let newSnake: Block[] = snake.slice();\n    newSnake.unshift(food);\n    return newSnake;\n}\n\nexport default eatFood;\n","import { ReactElement } from \"react\";\n\ninterface Props {\n    isGameOver: boolean;\n    score: number;\n}\n\nconst GameStatus: React.FC<Props> = (props): ReactElement<HTMLElement> => {\n    const isGameOver: boolean = props.isGameOver;\n    const score: number = props.score;\n\n    return (\n        <div>\n            <p>\n                <b>Score: </b> {score}\n                &nbsp; | &nbsp;\n                <b>Game status: </b> {isGameOver ? \"Game Over\" : \"In Progress\"}\n            </p>\n        </div>\n    )\n}\n\nexport default GameStatus;\n","/**\n * python like randInt\n * returns random int from given range (incl-excl)\n * @param {number}  min - minimum (incl)\n * @param {number}  max - maximum (excl)\n * @returns {number} random value from a given range\n */\nfunction randInt(min: number, max?: number): number {\n\n    let result: number = 0;\n\n    for (let i = 0; i < 2; i++) {\n        if (arguments[i] < 0) {\n            throw new Error(\"range must not include negative numbers\");\n        }\n    }\n    if (arguments.length === 1) {\n        max = min;\n        min = 0;\n    }\n    // floats protection\n    min = Math.ceil(min);\n    // should always be true,\n    // but the stricter angular checker requires me to do that way\n    if (max) {\n        max = Math.floor(max);\n        result = Math.floor(Math.random() * (max - min)) + min;\n    }\n\n    return result;\n}\n\nexport default randInt;\n","import Block from \"../interfaces/Block\";\n\nfunction isBlockInSnake(block: Block, snake: Block[]): boolean {\n    for (let i = 0; i < snake.length; i++) {\n        if (block.x === snake[i].x && block.y === snake[i].y) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport default isBlockInSnake;\n","import Block from \"../interfaces/Block\";\nimport randInt from \"./randInt\";\nimport isBlockInSnake from \"./isBlockInSnake\";\n\nfunction getRandBlock(minIncl: number, maxExcl: number): Block {\n    return { x: randInt(minIncl, maxExcl), y: randInt(minIncl, maxExcl) };\n}\n\nfunction getFreeRandBlock(minIncl: number, maxExcl: number, snake: Block[]): Block {\n    let randBlock: Block = getRandBlock(minIncl, maxExcl);\n    while (isBlockInSnake(randBlock, snake)) {\n        randBlock = getRandBlock(minIncl, maxExcl);\n    }\n    return randBlock;\n}\n\nexport default getFreeRandBlock;\n","import { ReactElement } from \"react\";\n\nconst Instructions: React.FC = (): ReactElement<HTMLElement> => {\n    return (\n        <div >\n            <p> <b>Instructions: </b> </p>\n            <span>\n                Start the game and the snake will move itself.\n                <br />\n                Press arrow keys on your keybord (&#8592; &#8593; &#8594; &#8595;) to change the direction of the snake\n                <br />\n                (turn 90 deg. right or left).\n                <br />\n                Collect food. Avoid collision with the walls and the snake's body.\n            </span>\n        </div>\n    )\n}\n\nexport default Instructions;\n","import Block from '../interfaces/Block';\nimport Direction from '../types/Direction';\n\n// x and y are like row, col in Python's pd.DataFrame\nfunction shiftBlock(block: Block, direction: Direction): Block {\n    if (direction === Direction.Up) {\n        return { x: block.x - 1, y: block.y };\n    } else if (direction === Direction.Down) {\n        return { x: block.x + 1, y: block.y };\n    } else if (direction === Direction.Right) {\n        return { x: block.x, y: block.y + 1 };\n    } else {\n        return { x: block.x, y: block.y - 1 };\n    }\n}\n\nfunction shiftSnake(snake: Block[], direction: Direction): Block[] {\n    let newSnake: Block[] = snake.slice(0, -1);\n    newSnake.unshift(shiftBlock(snake[0], direction))\n    return newSnake;\n}\n\nexport { shiftBlock, shiftSnake };\n","import { ReactElement } from \"react\";\n\nimport IRadioChoice from \"../interfaces/IRadioChoice\";\n\nimport \"./RadioSelect.css\";\n\ninterface Props {\n    mainLabel: string;\n    groupName: string;\n    choices: IRadioChoice[];\n    selectedChoice: number;\n    actionOnSelect: (chosenValue: number) => void;\n}\n\nconst RadioSelect: React.FC<Props> = (\n    props\n): ReactElement<HTMLElement> => {\n    const mainLabel: string = props.mainLabel;\n    const groupName: string = props.groupName;\n    const choices: IRadioChoice[] = props.choices;\n    const selectedChoice: number = props.selectedChoice;\n    const actionOnSelect: (chosenValue: number) => void = props.actionOnSelect;\n\n    const getRadio = (choice: IRadioChoice): ReactElement<HTMLElement> => {\n        return (\n            <span key={choice.id}>\n                <input\n                    type=\"radio\"\n                    value={choice.name}\n                    name={groupName}\n                    onChange={() => onSelect(choice)}\n                    checked={selectedChoice === choice.value}\n                />\n                <label htmlFor={choice.name} onClick={() => onSelect(choice)}>\n                    {choice.name}\n                </label>\n            </span>\n        );\n    };\n\n    const onSelect = (choice: IRadioChoice): void => {\n        actionOnSelect(choice.value);\n    };\n\n    return (\n        <form action=\"\">\n            <fieldset>\n                <legend>{mainLabel}</legend>\n                {choices.map((c) => getRadio(c))}\n            </fieldset>\n        </form>\n    );\n};\n\nexport default RadioSelect;\n","import Block from \"../interfaces/Block\";\nimport Direction from \"../types/Direction\";\nimport { shiftBlock } from \"./shiftSnake\";\n\nfunction willSnakeHitWall(snake: Block[], direction: Direction,\n    noOfRows: number): boolean {\n    let newHead: Block = shiftBlock(snake[0], direction);\n    let outOfX: boolean = newHead.x < 0 || newHead.x >= noOfRows;\n    let outOfY: boolean = newHead.y < 0 || newHead.y >= noOfRows;\n    return outOfX || outOfY;\n}\n\nexport default willSnakeHitWall;\n","import Block from \"../interfaces/Block\";\nimport Direction from \"../types/Direction\";\nimport isBlockInSnake from \"./isBlockInSnake\";\nimport { shiftBlock } from \"./shiftSnake\";\n\nfunction willSnakeEatItself(snake: Block[], direction: Direction): boolean {\n    let newHead: Block = shiftBlock(snake[0], direction);\n    return isBlockInSnake(newHead, snake);\n}\n\nexport default willSnakeEatItself;\n","import React, { useState, useEffect, ReactElement } from \"react\";\n\nimport Block from \"./interfaces/Block\";\nimport Button from \"./components/Button\";\nimport config from \"./config/config\";\nimport Canvas from \"./components/canvas/Canvas\";\nimport Direction from \"./types/Direction\";\nimport eatFood from \"./utils/eatFood\";\nimport GameStatus from \"./components/GameStatus\";\nimport getFreeRandBlock from \"./utils/getRandBlock\";\nimport Instructions from \"./components/Instructions\";\nimport IRadioChoice from \"./interfaces/IRadioChoice\";\nimport { shiftBlock, shiftSnake } from \"./utils/shiftSnake\";\nimport RadioSelect from \"./components/RadioSelect\";\nimport willSnakeHitWall from \"./utils/willSnakeHitWall\";\nimport willSnakeEatItself from \"./utils/willSnakeEatItself\";\n\nimport \"./App.css\";\n\nconst App: React.FC = (): ReactElement<HTMLElement> => {\n    const [delay, setDelay]: [number, Function] = useState(config.delay);\n    const delays: IRadioChoice[] = [\n        { id: 0, name: \"1 sec\", value: 1000 },\n        { id: 1, name: \"0.8 sec\", value: 800 },\n        { id: 2, name: \"0.6 sec\", value: 600 },\n    ];\n    const [food, setFood]: [Block, Function] = useState(config.food);\n    const [gameOver, setGameOver]: [boolean, Function] = useState(true);\n    // nRows is always equal nCols\n    const [nRows, setNrows]: [number, Function] = useState(config.nOfRows);\n    // value in gridSizes is nOfRows\n    const gridSizes: IRadioChoice[] = [\n        { id: 0, name: \"5x5\", value: 5 },\n        { id: 1, name: \"6x6\", value: 6 },\n        { id: 2, name: \"7x7\", value: 7 },\n        { id: 3, name: \"8x8\", value: 8 },\n    ]\n    const [maxSnakeLength, setMaxSnakeLength]: [number, Function] = useState(\n        nRows * nRows\n    )\n    const [moveDirection, setMoveDirection]: [Direction, Function] = useState(\n        Direction.Right\n    );\n    const [snake, setSnake]: [Block[], Function] = useState(config.snake);\n    const [score, setScore]: [number, Function] = useState(snake.length);\n\n    const startClickHandler = (): void => {\n        setScore(snake.length);\n        setGameOver(false);\n    };\n\n    const radioSelectSpeedHandler = (delayMicroSecs: number): void => {\n        setDelay(delayMicroSecs);\n    };\n    const radioSelectGridHandler = (nOfRows: number): void => {\n        setNrows(nOfRows);\n        setMaxSnakeLength(nOfRows * nOfRows);\n    };\n\n    useEffect(() => {\n        const handleKeyDown = (event: KeyboardEvent) => {\n            let newDirection: Direction = moveDirection;\n            if (event.key === \"ArrowLeft\") {\n                newDirection = Direction.Left;\n            }\n            if (event.key === \"ArrowUp\") {\n                newDirection = Direction.Up;\n            }\n            if (event.key === \"ArrowRight\") {\n                newDirection = Direction.Right;\n            }\n            if (event.key === \"ArrowDown\") {\n                newDirection = Direction.Down;\n            }\n            if (\n                newDirection !== moveDirection &&\n                Math.abs(newDirection - moveDirection) !== 9\n            ) {\n                setMoveDirection(newDirection);\n            }\n        };\n        document.addEventListener(\"keydown\", handleKeyDown);\n        return () => {\n            document.removeEventListener(\"keydown\", handleKeyDown);\n        };\n    }, [moveDirection]);\n\n    useEffect(() => {\n        const initializeGame = (): void => {\n            setSnake(config.snake);\n            setFood(config.food);\n            setMoveDirection(Direction.Right);\n        };\n        const moveSnake = (): void => {\n            setSnake((prevSnake: Block[]) => {\n                return shiftSnake(prevSnake, moveDirection);\n            });\n        };\n        const willSnakeEatFood = (): boolean => {\n            let newHead: Block = shiftBlock(snake[0], moveDirection);\n            return newHead.x === food.x && newHead.y === food.y;\n        };\n        const growSnake = (): void => {\n            setSnake((prevSnake: Block[]) => {\n                return eatFood(prevSnake, food);\n            });\n        };\n        const setNewFood = (newSnake: Block[]): void => {\n            setFood(getFreeRandBlock(0, nRows, newSnake));\n        };\n\n        const isGameOver = (): boolean => {\n            return (\n                willSnakeHitWall(snake, moveDirection, nRows) ||\n                willSnakeEatItself(snake, moveDirection)\n            );\n        };\n\n        const onGameOver = (): void => {\n            clearInterval(timerId);\n            initializeGame();\n        };\n\n        let timerId = setInterval(() => {\n            if (gameOver) {\n                onGameOver();\n            } else {\n                if (willSnakeEatFood()) {\n                    // otherwise while loop in getFreeRandBlock (in setNewFood)\n                    // is infinite\n                    if (snake.length === maxSnakeLength - 1) {\n                        setScore((prevScore: number) => prevScore + 1);\n                        setGameOver(true);\n                    } else {\n                        // necessary,\n                        // rendering is lagging about 1 frame behind code\n                        // otherwise, new food may come in head\n                        setScore((prevScore: number) => prevScore + 1);\n                        setNewFood(eatFood(snake, food));\n                        growSnake();\n                    }\n                } else {\n                    moveSnake();\n                }\n            }\n            if (isGameOver()) {\n                setGameOver(true);\n            }\n        }, delay);\n        return () => {\n            clearInterval(timerId);\n        };\n    }, [delay, food, gameOver, nRows, maxSnakeLength, moveDirection, score, snake]);\n\n    return (\n        <div className=\"App\">\n            <Instructions />\n            <GameStatus isGameOver={gameOver} score={score} />\n            {gameOver && (\n                <Button onClick={startClickHandler} displText={\"start game\"} />\n            )}\n            <Canvas snake={snake} food={food} isGameOver={gameOver} score={score}\n                nRows={nRows} />\n            {gameOver && (\n                <RadioSelect\n                    mainLabel={\"Choose move delay\"}\n                    groupName=\"speed\"\n                    choices={delays}\n                    selectedChoice={delay}\n                    actionOnSelect={radioSelectSpeedHandler}\n                />\n            )}\n            {gameOver && (\n                <RadioSelect\n                    mainLabel={\"Choose grid size\"}\n                    groupName={\"grid\"}\n                    choices={gridSizes}\n                    selectedChoice={nRows}\n                    actionOnSelect={radioSelectGridHandler}\n                />\n            )}\n        </div>\n    );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}